# encoding: utf-8
import configparser
import csv
import datetime
import sys
import time
from enum import Enum
from pathlib import Path

from pymetasploit3 import msfrpc


class MetasploitExternalModule:
    def __init__(self, msf_logger, password, module_type, module_name, exploit_options, payload=None):
        self.logger = msf_logger
        self.client = msfrpc.MsfRpcClient(password)
        self.module_type = module_type
        self.module_name = module_name
        self.exploit_options = exploit_options

        if payload is not None:
            payload_module = self.client.modules.use('payload', payload['PAYLOAD'])
            for opt_key, opt_val in payload.items():
                if opt_key == 'PAYLOAD':
                    continue
                payload_module[opt_key] = opt_val
            self.payload = payload_module
        else:
            self.payload = None

        self.job = {"job_id": None, "uuid": None}

    def attempt_break_in(self, timeout, number_attempts=1):
        self.logger.log_begin_break_in(number_attempts, self.exploit_options)
        for i in range(1, number_attempts + 1):
            self.logger.log_begin_attempt()
            # print("attempt {}/{}".format(i, number_attempts))
            self.run_module()
            self.await_job_finish()
            self.logger.log_end_job()

            possible_session = self.await_session_creation_last_job(timeout)
            if possible_session is not None:
                # print("success.")
                self.logger.log_success(possible_session)
                return
            # print("no success...")
            self.logger.log_no_session_created()

    def get_last_job_did_pwn(self):
        return self.get_session_by_last_exploit() is not None

    def get_session_by_last_exploit(self):
        return self.get_session_by_exploit_uuid(self.job["uuid"])

    def get_session_list(self):
        return self.client.sessions.list

    def get_job_is_running(self):
        return self.job["job_id"] in self.get_job_list()

    def get_job_list(self):
        return self.client.jobs.list

    def get_session_by_exploit_uuid(self, uuid):
        for session_number, session in self.get_session_list().items():
            if session["exploit_uuid"] == uuid:
                return session
        return None

    def run_module(self):
        """
        Run a module with specified parameters.
        """
        exploit = self.client.modules.use(self.module_type, self.module_name)
        exploit.update(self.exploit_options)
        if len(exploit.missing_required) > 0:
            raise MissingOptionsError("The following options are missing {}".format(exploit.missing_required))
        self.job = {"job_id": None, "uuid": None}
        self.job = exploit.execute(payload=self.payload)
        if "job_id" not in self.job:
            self.logger.log_module_error()
            raise ExploitError("Error while running exploit")
        return self.job["job_id"], self.job["uuid"]

    def await_session_creation_last_job(self, timeout=8):
        return self.await_session_creation_by_uuid(self.job["uuid"], timeout)

    def await_session_creation_by_uuid(self, uuid, timeout):
        for timer in range(0, timeout):
            session = self.get_session_by_exploit_uuid(uuid)
            if session is not None:
                return session
            time.sleep(1)
        return None

    def await_job_finish(self):
        while self.get_job_is_running():
            time.sleep(1)


class ExploitError(Exception):
    pass


class MissingOptionsError(Exception):
    pass


class ConfigIncompleteError(Exception):
    pass


class MsfConfig:
    def __init__(self, path_to_config):
        self.config = configparser.ConfigParser()
        self.config.optionxform = str
        self.config.read(filenames=path_to_config)
        self.module = self.config['MSF_MODULE']
        self.mod_options = self.config['MSF_MODULE_OPTIONS']
        self.payload_options = self.config['MSF_PAYLOAD_OPTIONS']


class MsfConnectionConfig:
    def __init__(self, path_to_config):
        self.config = configparser.ConfigParser()
        self.config.optionxform = str
        self.config.read(filenames=path_to_config)
        self.connection = self.config['MSF_CONNECTION']


class MsfLoggerEvents(Enum):
    BEGIN_BREAK_IN_OPERATION = "BEGIN_BREAK_IN_OPERATION"
    BEGIN_ATTEMPT = "BEGIN_ATTEMPT"
    JOB_ENDED = "JOB_ENDED"
    BREAK_IN_SUCCESS = "BREAK_IN_SUCCESS"
    BREAK_IN_FAIL = "BREAK_IN_FAIL"
    MODULE_ERROR = "MODULE_ERROR"


class MsfLogger:
    def __init__(self, flow_id, log_dir):
        self.flow_id = flow_id
        self.log_dir = log_dir
        if self.log_dir is None:
            self.log_file_path = None
            return
        self.log_file_path = Path(log_dir) / Path("{}_msf_log_{}".format(flow_id, datetime.datetime.now()))

    def write_with_time(self, event, text=""):
        if self.log_file_path is None:
            return
        values = [time.time(), self.flow_id, event.name, text]
        self.write_to_csv(values)

    def log_begin_break_in(self, number_of_tries, options):
        # print("{} - beginning break-in, trying {} times, options {}".format(self.flow_id, number_of_tries, options))
        self.write_with_time(MsfLoggerEvents.BEGIN_BREAK_IN_OPERATION, str(options))

    def log_begin_attempt(self):
        # print("{} - running job".format(self.flow_id))
        self.write_with_time(MsfLoggerEvents.BEGIN_ATTEMPT)

    def log_end_job(self):
        # print("{} - job ended".format(self.flow_id))
        self.write_with_time(MsfLoggerEvents.JOB_ENDED)

    def log_success(self, session_info):
        # print("{} - module success and opened session {}".format(self.flow_id, session_info))
        self.write_with_time(MsfLoggerEvents.BREAK_IN_SUCCESS, session_info)

    def log_no_session_created(self):
        # print("{} - attempt ended, no session opened".format(self.flow_id))
        self.write_with_time(MsfLoggerEvents.BREAK_IN_FAIL)

    def log_module_error(self):
        # print("{} - error while executing module!".format(self.flow_id))
        self.write_with_time(MsfLoggerEvents.MODULE_ERROR)

    def write_to_csv(self, values):
        with open(self.log_file_path, 'a+') as file:
            csv_parser = csv.writer(file)
            csv_parser.writerow(values)
            file.close()


def main():
    # values passed from gpntf:
    # - flow_id
    # - repeat break-in attempts how many times?
    # - path to msf-config -> contains modules specific options, payload, etc.
    # - logging directory
    usage_message = "{} <flow_id> <break-in-attempts> <connection_config_file> <config_file> (<logging_dir>)"
    if len(sys.argv) < 4:
        print(usage_message.format(sys.argv[0]))
        return
    flow_id = sys.argv[1]
    attempts = sys.argv[2]
    msf_connection_conf = MsfConnectionConfig(sys.argv[3])
    msf_conf = MsfConfig(sys.argv[4])

    module_options = {}
    for key in msf_conf.mod_options.keys():
        module_options[key] = msf_conf.mod_options[key]

    payload_options = {}
    for key in msf_conf.payload_options.keys():
        payload_options[key] = msf_conf.payload_options[key]

    if sys.argv[5] is None:
        logpath = None
    else:
        logpath = sys.argv[5]

    logger = MsfLogger(flow_id, logpath)
    msf = MetasploitExternalModule(msf_logger=logger,
                                   password=msf_connection_conf.connection['password'],
                                   module_type=msf_conf.module['module_type'],
                                   module_name=msf_conf.module['module_name'],
                                   exploit_options=module_options,
                                   payload=payload_options
                                   )
    msf.attempt_break_in(timeout=10, number_attempts=int(attempts))
    print("done.")


main()
