//
// Created by philipp on 04.03.19.
//

#ifndef GPNTF_MSF_RPC_EXPLOIT_DTO_H
#define GPNTF_MSF_RPC_EXPLOIT_DTO_H


#include <msgpack/adaptor/string.hpp>

struct MSF_RPC_Error_DTO {
    bool error;
    std::string error_class;
    std::string error_message;

    MSGPACK_DEFINE_MAP(error, error_class, error_message);
};

struct MSF_RPC_Datastore_DTO {
    MSF_RPC_Datastore_DTO(const std::string &RHOSTS, const std::string &RPORT, const std::string &USERPASS_FILE)
            : RHOSTS(RHOSTS), RPORT(RPORT), USERPASS_FILE(USERPASS_FILE) {}

    std::string RHOSTS;
    std::string RPORT;
    std::string USERPASS_FILE;

    MSGPACK_DEFINE_MAP(RHOSTS, RPORT, USERPASS_FILE);
};

struct MSF_RPC_Exploit_DTO {

    MSF_RPC_Exploit_DTO(const std::string &token, const std::string &type, const std::string &name,
                        const MSF_RPC_Datastore_DTO &datastore) : token(token), type(type), name(name),
                                                                  datastore(datastore) {}

    std::string command = "module.execute";
    std::string token;
    std::string type;
    std::string name;
    MSF_RPC_Datastore_DTO datastore;
    MSGPACK_DEFINE (command, token, type, name, datastore);
};

class MSF_RPC_Sessions_DTO {

public:
    MSF_RPC_Sessions_DTO(const std::string &type, const std::string &via_exploit, const std::string &info,
                         const std::string &target_host, const std::string &exploit_uuid) : type(type),
                                                                                            via_exploit(via_exploit),
                                                                                            info(info),
                                                                                            target_host(target_host),
                                                                                            exploit_uuid(
                                                                                                    exploit_uuid) {}

    MSF_RPC_Sessions_DTO() {}

    std::string type;
//    std::string tunnel_local;
//    std::string tunnel_peer;
    std::string via_exploit;
//    std::string via_payload;
//    std::string desc;
    std::string info;
//    std::string workspace;
//    std::string session_host;
//    unsigned int session_port;
    std::string target_host;
//    std::string username;
//    std::string uuid;
    std::string exploit_uuid;
//    std::string routes;
//    std::string arch;

//    MSGPACK_DEFINE_MAP(type, via_exploit, info, target_host);

};
namespace msgpack {
    MSGPACK_API_VERSION_NAMESPACE(MSGPACK_DEFAULT_API_NS) {
        namespace adaptor {

// Place class template specialization here
            template<>
            struct convert<MSF_RPC_Sessions_DTO> {
                msgpack::object const &operator()(msgpack::object const &o, MSF_RPC_Sessions_DTO &v) const {
                    if (o.type != msgpack::type::MAP) throw msgpack::type_error();
//                    if (o.via.map.size  2) throw msgpack::type_error();

                    std::string type;
                    std::string via_exploit;
                    std::string info;
                    std::string target_host;
                    std::string exploit_uuid;

                    for (int i = 0; i < o.via.map.size; i++) {
                        parseString(o, i, type, "type");
                        parseString(o, i, via_exploit, "via_exploit");
                        parseString(o, i, info, "info");
                        parseString(o, i, target_host, "target_host");
                        parseString(o, i, exploit_uuid, "exploit_uuid");
                    }
                    v = MSF_RPC_Sessions_DTO(type, via_exploit, info, target_host, exploit_uuid);

                    return o;
                }

                static void parseString(const msgpack::object &o, int &i, std::string &value, std::string valueName) {
                    if (o.via.map.ptr[i].key.as<std::string>() == valueName) {
                        value = o.via.map.ptr[i].val.as<std::string>();
                    }
                }
            };


        }
    }
}

class MSF_RPC_JobId_DTO {

public:
    MSF_RPC_JobId_DTO() = default;

    MSF_RPC_JobId_DTO(int job_id, std::string uuid) : job_id(job_id), uuid(std::move(uuid)) {}


    int job_id;
    std::string uuid;

//    MSGPACK_DEFINE_MAP(job_id, uuid);

};


namespace msgpack {
    MSGPACK_API_VERSION_NAMESPACE(MSGPACK_DEFAULT_API_NS) {
        namespace adaptor {
// Place class template specialization here
            template<>
            struct convert<MSF_RPC_JobId_DTO> {
                msgpack::object const &operator()(msgpack::object const &o, MSF_RPC_JobId_DTO &v) const {
                    if (o.type != msgpack::type::MAP) throw msgpack::type_error();
                    if (o.via.map.size != 2) throw msgpack::type_error();
                    int job_id = 0;
                    std::string uuid;

                    for (int i = 0; i < o.via.map.size; i++) {
                        if (o.via.map.ptr[i].key.as<std::string>() == "job_id") {
                            job_id = o.via.map.ptr[i].val.as<int>();
                        }
                        if (o.via.map.ptr[i].key.as<std::string>() == "uuid") {
                            uuid = o.via.map.ptr[i].val.as<std::string>();
                        }
                    }
                    v = MSF_RPC_JobId_DTO(job_id, uuid);

                    return o;
                }
            };


            template<>
            struct pack<MSF_RPC_JobId_DTO> {
                template<typename Stream>
                packer <Stream> &operator()(msgpack::packer<Stream> &o, MSF_RPC_JobId_DTO const &v) const {
                    // packing member variables as an array.
                    o.pack_map(2);
                    o.pack("job_id");
                    o.pack(v.job_id);
                    o.pack("uuid");
                    o.pack(v.uuid);
                    return o;
                }
            };
        }
    }
}

class MSF_RPC_JobMap_DTO {

public:
    MSF_RPC_JobMap_DTO() { jobMap = std::map<std::string, std::string>(); }

    std::map<std::string, std::string> jobMap;
};


namespace msgpack {
    MSGPACK_API_VERSION_NAMESPACE(MSGPACK_DEFAULT_API_NS) {
        namespace adaptor {
// Place class template specialization here
            template<>
            struct convert<MSF_RPC_JobMap_DTO> {
                msgpack::object const &operator()(msgpack::object const &o, MSF_RPC_JobMap_DTO &v) const {
                    if (o.type != msgpack::type::MAP) throw msgpack::type_error();

                    for (int i = 0; i < o.via.map.size; i++) {
                        if (o.via.map.ptr[i].key.type != msgpack::type::STR) {
                            continue;
                        }
                        if (o.via.map.ptr[i].key.type != msgpack::type::STR) {
                            std::cout << "crazy key type!";
                        }
                        std::cout << "found key " << o.via.map.ptr[i].key.as<std::string>() << " val "
                                  << o.via.map.ptr[i].val.as<std::string>();
                        v.jobMap.insert(std::pair<std::string, std::string>(o.via.map.ptr[i].key.as<std::string>(),
                                                                            o.via.map.ptr[i].val.as<std::string>()));
                    }
                    return o;
                }
            };
        }
    }
}

#endif //GPNTF_MSF_RPC_EXPLOIT_DTO_H
