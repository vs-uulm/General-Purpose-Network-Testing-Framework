//
// Created by philipp on 12.03.19.
//

#ifndef GPNTF_MSF_ETERNALBLUE_RPC_H
#define GPNTF_MSF_ETERNALBLUE_RPC_H

#include <string>
#include <thread>
#include "MSF_RPC.h"
#include "../../reporting/Reporter.hpp"

#define CHECK_JOB_RUNNING_DELAY 2


class MSF_RPC_Module {
public:
    MSF_RPC_Module(unsigned int id, const std::string &logPath, const std::string &msfUsername,
                   const std::string &msfPassword, const std::string &msfUrl, unsigned int numberOfTries,
                   const MSF_RPC_Exploit &exploit) : id(id), logPath(logPath), msfUsername(msfUsername),
                                                     msfPassword(msfPassword), msfUrl(msfUrl),
                                                     numberOfTries(numberOfTries), exploit(exploit) {}

    int startSession() {
        Reporter rep{id, path{logPath}, "exploit"};
        MSF_RPC metasploit{msfUrl, msfUsername, msfPassword};
        metasploit.login();

        rep.logBeginFlow();


        bool exploitSuccess = false;
        for (int i = 1; i <= numberOfTries; i++) {
            print_status(id, "INFO", create_status_try_of("Starting exploit ", i, numberOfTries), "");

            MSF_RPC_JobId_DTO jobResult;
            metasploit.exploit(exploit, jobResult);
            print_status(id, "INFO", "Exploit running!", "");

            monitorExploitStatus(metasploit, jobResult, exploitSuccess, rep);
            if (exploitSuccess) {
                print_status(id, "INFO", "Exploit SUCCESS!", "");
            } else {
                print_status(id, "INFO", "Exploit has not created a sesssion, continuing...", "");
            }
        }

        return 0;
    }

    int monitorExploitStatus(MSF_RPC &metasploit, MSF_RPC_JobId_DTO &jobResult, bool &exploitSuccess, Reporter &rep) {
        bool jobIsRunning = false;
        metasploit.getJobIsRunning(jobResult.job_id, jobIsRunning);
        while (jobIsRunning) {
            metasploit.getJobIsRunning(jobResult.job_id, jobIsRunning);
            if(jobIsRunning) {
                std::cout << "Job still running..." << std::endl;
            }
            std::this_thread::sleep_for(std::chrono::seconds(CHECK_JOB_RUNNING_DELAY));
        }
        print_status(id, "INFO", "Job has ended, checking if session was created...", "");

        bool sessionCreated = false;
        MSF_RPC_Sessions_DTO session;
        metasploit.getSessionByExploitUuid(jobResult.uuid, session, sessionCreated);
        if (sessionCreated) {
            rep.logEndFlow();
            rep.logExploitSuccess();
        }
        exploitSuccess = sessionCreated;
        return 0;
    }

private:
    unsigned int id;
    std::string logPath;
    std::string msfUsername;
    std::string msfPassword;
    std::string msfUrl;
    unsigned int numberOfTries;
    MSF_RPC_Exploit exploit;

    std::string create_status_try_of(const std::string &message, const int &tryIterator, const int &numberOfTries) {
        std::stringstream sstream{};
        sstream << message << " try " << tryIterator << " of " << numberOfTries;
        return sstream.str();
    }
};

#endif //GPNTF_MSF_ETERNALBLUE_RPC_H
