//
// Created by philipp on 02.03.19.
//

#ifndef GPNTF_MSF_RPC_H
#define GPNTF_MSF_RPC_H

#include "msgpack.hpp"
#include "curlpp/Easy.hpp"
#include "curlpp/cURLpp.hpp"
#include "curlpp/Options.hpp"
#include <curlpp/Infos.hpp>
#include <codecvt>
#include "MSF_RPC_Exploit.h"
#include "MSF_RPC_Exploit_DTO.h"
#include <iostream>
#include <fstream>

class MSF_RPC {
public:
    MSF_RPC(const std::string &url, const std::string &username, const std::string &password) : url(url),
                                                                                                username(username),
                                                                                                password(password) {}

    void getJobIsRunning(int &jobId, bool &isRunning) {
        std::map<std::string, std::string> runningJobs;
        getJobList(runningJobs);

        isRunning = runningJobs.find(std::to_string(jobId)) != runningJobs.end();
    }

    void getJobInfo(unsigned int jobId) {
        std::vector<std::string> vec = {"job.info", tempToken, std::to_string(jobId)};
        std::cout << "sending: " << jobId << std::endl;

        std::map<std::string, std::string> resultMap{};
        long statusCode;
        serializeSendDeserializeMap(vec, resultMap, statusCode);

        if (statusCode == 200) {
            std::cout << "job module name: " << resultMap.at("name") << ", started at " << resultMap.at("start_time")
                      << std::endl;
        } else {
            std::cout << "Error with code " << statusCode << ": " << resultMap.at("error_message") << std::endl;
        }
    }

    void getJobList(std::map<std::string, std::string> &resultMap) {
        std::vector<std::string> vec = {"job.list", tempToken};
        long statusCode;
        std::map<std::string, std::vector<char>> tmpMap{};
        msgpack::object result;
        serializeSendDeserializeObj(vec, result, statusCode);
        try {
            auto jobMap = result.as<MSF_RPC_JobMap_DTO>();
            resultMap = jobMap.jobMap;
        }
        catch (std::bad_cast &bc) {
            std::cout << "bad cast in getJobList()";
            throw bc;
        }
    }

    void getSessionList(std::map<int, MSF_RPC_Sessions_DTO> &resultMap) {
        std::vector<std::string> vec = {"session.list", tempToken};
        long statusCode;

        msgpack::object resultObj;
        serializeSendDeserializeObj(vec, resultObj, statusCode);

        try {
            auto tmpMap = resultObj.as<MSF_RPC_Sessions_DTO>();
        } catch (std::bad_cast bc) {
            std::cerr << "bad cast in getSessionList()";
        }
    }

    void getSessionByExploitUuid(const std::string &uuid, MSF_RPC_Sessions_DTO &session, bool &sessionExists) {
        std::map<int, MSF_RPC_Sessions_DTO> sessions;
        getSessionList(sessions);

        for (auto const &entry: sessions) {
            if (entry.second.exploit_uuid == uuid) {
                session = entry.second;
                return;
            }
        }
    }

    int exploit(MSF_RPC_Exploit exploit, MSF_RPC_JobId_DTO &jobResult) {
        MSF_RPC_Datastore_DTO datastoreDto{exploit.RHOSTS, exploit.RPORT, exploit.passfile};
        MSF_RPC_Exploit_DTO exploitDto{tempToken, exploit.type, exploit.name, datastoreDto};

        serializeSendDeserializeExecutor(exploitDto, jobResult);

        std::cout << "started job with id: " << std::to_string(jobResult.job_id) << std::endl;
        return jobResult.job_id;
    }

    void login() {
        std::vector<std::string> vec = {"auth.login", username, password};

        std::map<std::string, std::string> resultMap{};
        long statusCode;
        serializeSendDeserializeMap(vec, resultMap, statusCode);

        std::cout << "token is: " << resultMap.at("token") << std::endl;
        tempToken = resultMap.at("token");
//        loginPerm();
    }

    void loginPerm() {
        if (tempToken.empty()) {
            return;
        }
        std::vector<std::string> vec = {"auth.token_generate", tempToken};

        std::map<std::string, std::string> resultMap{};
        long statusCode;
        serializeSendDeserializeMap(vec, resultMap, statusCode);

        std::cout << "permanent token is: " << resultMap.at("token") << std::endl;
        permToken = resultMap.at("token");
    }

    void version() {
        std::vector<std::string> vec = {"core.version", tempToken};

        std::map<std::string, std::string> resultMap{};
        long statusCode;
        serializeSendDeserializeMap(vec, resultMap, statusCode);

        std::cout << "version is: " << resultMap.at("version")
                  << " ruby version: " << resultMap.at("ruby")
                  << " api version: " << resultMap.at("api") << std::endl;
    }

private:
    std::string url;
    std::string username;
    std::string password;
    std::string tempToken;
    std::string permToken;

    void printMsgPack(char *&input) {

        msgpack::object_handle oh =
                msgpack::unpack(input, std::strlen(input));
        // print the deserialized object.
        msgpack::object obj = oh.get();
        std::cout << obj << std::endl;
    }

    void serializeSendDeserializeObj(const std::vector<std::string> &inputVec, msgpack::object &obj,
                                     long &statusCode) {
        std::stringstream buffer{};
        buffer.clear();
        msgpack::pack(buffer, inputVec);

        std::cout << "sending: " << buffer.str() << std::endl;
        std::string resultRaw = sendRequest(buffer.str().data(), statusCode);

        std::ofstream debugFile;
        debugFile.open("debug_msgpack.mp");
        debugFile << resultRaw.data();
        debugFile.close();

        obj = deserializeString(resultRaw);
    }

    void
    serializeSendDeserializeMap(const std::vector<std::string> &inputVec, std::map<std::string, std::string> &resultMap,
                                long &statusCode) {
        std::stringstream buffer{};
        buffer.clear();
        msgpack::pack(buffer, inputVec);

        std::cout << "sending: " << buffer.str() << std::endl;
        std::string resultRaw = sendRequest(buffer.str().data(), statusCode);
        msgpack::object result = deserializeString(resultRaw);

        try {
            resultMap = result.as<std::map<std::string, std::string>>();
        } catch (std::bad_cast &bc) {
            std::cerr << "bad cast found";
        }
    }

    void serializeSendDeserializeExecutor(MSF_RPC_Exploit_DTO &dto, MSF_RPC_JobId_DTO &result) {
        std::stringstream buffer{};
        buffer.clear();
        msgpack::pack(buffer, dto);

        std::cout << "sending: " << buffer.str() << std::endl;
        std::string resultRaw = sendRequest(buffer.str().data());

        result = deserializeStringJobId(resultRaw);
    }

    std::string sendRequest(char *input) {
        long code;
        return sendRequest(input, code);
    }

    std::string sendRequest(char *input, long &statusCode) {

        curlpp::Cleanup myCleanup;

        curlpp::Easy myRequest;
        myRequest.setOpt<curlpp::options::Url>(url);

        std::list<std::string> header;
        header.emplace_back("Content-Type: binary/message-pack");

        myRequest.setOpt(new curlpp::options::HttpHeader(header));
        myRequest.setOpt<curlpp::options::PostFields>(input);
        myRequest.setOpt(new curlpp::options::PostFieldSize(strlen(input)));

        std::stringstream outputStream;
        outputStream.clear();
        char *errorBuffer = const_cast<char *>("");

        myRequest.setOpt(new curlpp::options::WriteStream(&outputStream));
        myRequest.setOpt(new curlpp::options::ErrorBuffer(errorBuffer));
        myRequest.perform();
        std::cout << "status code: "
                  << curlpp::infos::ResponseCode::get(myRequest) << std::endl;
        statusCode = curlpp::infos::ResponseCode::get(myRequest);
        return outputStream.str();
    }

    msgpack::object deserializeString(std::string &inputString) {
        msgpack::object_handle oh = msgpack::unpack(inputString.data(), inputString.length());
        msgpack::object obj = oh.get();
        std::cout << obj << std::endl;

        return obj;
    }

    MSF_RPC_JobId_DTO deserializeStringJobId(std::string &inputString) {
        msgpack::object_handle oh = msgpack::unpack(inputString.data(), inputString.length());
        msgpack::object obj = oh.get();
        std::cout << obj << std::endl;

        return obj.as<MSF_RPC_JobId_DTO>();
    }


};


#endif //GPNTF_MSF_RPC_H
