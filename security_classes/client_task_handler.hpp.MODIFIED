#ifndef CLIENT_TASK_HANDLER_HPP
#define CLIENT_TASK_HANDLER_HPP

#define MODE_REGULAR "regular"
#define MODE_RAW "raw"
#define MODE_ATTACK "attack"
#define MODE_EXTERN "extern"


/* --- General Parameters ---*/
#define NOF_CONNECTIONS "numberOfConnections"
#define DEFAULT_NOF_CONNECTIONS 1
#define SESSION_LENGTH "sessionLength"
#define DEFAULT_SESSION_LENGTH 10

/* --- EXTERN mode Parameters ---*/
#define VOD "VoD"
#define MARKETPLACE "marketplace"
#define STORAGE "storage"

/* --- L4 PROTOCOLS --- */
#define LAYER4_TCP "tcp"
#define LAYER4_UDP "udp"

/* --- L7 PROTOCOLS --- */
#define LAYER7_1460B "f1460b"

/* --- Security Parameters ---*/
#define SYNFLOOD "synflood"
#define UDPFLOOD "udpflood"
#define SLOWLORIS "slowloris"
#define  SLOWPOST   "slowpost"
#define METASPLOIT "metasploit"
#define PORTSCAN "portscan"

#define NOF_CONNECTIONS "numberOfConnections"
/* --- WEB BROWSING --- */
#define LAYER7_WEBBROWSING "webBrowsing"
#define WEB_BROWSING_DEFAULT_SESSION_LENGTH 10
#define WEB_BROWSING_DEFAULT_REQUEST_SIZE 350

/* --- FILE SHARING --- */
#define LAYER7_FILESHARING "filesharing"
#define IDLE_TIME "idleTime"
#define DEFAULT_IDLE_TIME 0

/* --- STORAGE/MARKETPLACE ---*/
#define OPMODE "opMode"
#define UPLOAD "upload"
#define DOWNLOAD "download"
#define ITERATIONS 1 // defines how often the given file is downloaded

/* --- L7 MODES --- */
#define LAYER7_1460B_CONST "const"

#include "../misc/useful_functions.hpp"
#include "L4.hpp"
// #include "L7.hpp" mother class; is included in child classes
#include "L7_web_browsing.hpp"
#include "L7_file_sharing.hpp"
#include "L7_vod.hpp"
#include "L7_storage_marketplace.hpp"
#include "flooding/L7_slowloris.cpp"
#include "flooding/L7_SlowPost.cpp"
#include "../misc/Distribution_Functions.hpp"
#include "legacy/MSF_EternalBlue.cpp"
#include "legacy/MSF_SSH_bruteforce.h"
#include "exploit/PortScan.h"
#include "exploit/ExternalMetasploit.h"
#include "flooding/utils.hpp"
#include "flooding/L4_Flooding.h"
#include "flooding/L4_syn_flooding.cpp"
#include "flooding/L4_udp_flooding.cpp"
#include "flooding/L4_distributed_flooding.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <cstring>
#include <unistd.h>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <vector>

template<class Key, class Value>
class ClientTaskHandler {
public:
    ClientTaskHandler(unsigned int &_id, std::map<Key, Value> const &_parameters) : id{_id}, parameters{_parameters} {
        print_status(id, "INFO", "Handler object has been created...", "");
    }

    void
    start() {
        // Determine mode
        std::string mode;
        find_and_return_parameter("mode", mode);
        if (mode != "false") {
            if (mode == MODE_REGULAR) {
                print_status(id, "INFO", "Client starts in NORMAL mode", "");
                if (start_regular() < 0) {
                    print_status(id, "ERROR", "Exiting...", "");
                    exit(EXIT_FAILURE);
                }
            } else if (mode == MODE_RAW) {
                print_status(id, "INFO", "Client starts RAW mode", "");
            } else if (mode == MODE_ATTACK) {
                print_status(id, "INFO", "Client starts in ATTACK mode", "");
                if (start_attack() < 0) {
                    print_status(id, "ERROR", "Exiting...", "");
                    exit(EXIT_FAILURE);
                }

            } else if (mode == MODE_EXTERN) {
                print_status(id, "INFO", "Client starts in EXTERN mode", "");
                if (start_extern() < 0) {
                    print_status(id, "ERROR", "Exiting...", "");
                    exit(EXIT_FAILURE);
                }
            } else {
                print_status(id, "ERROR", "Could not find 'layer4Protocol' entry in parameter list");
                exit(EXIT_FAILURE);
            }
        } else {
            print_status(id, "ERROR", "Could not find mode entry in parameter list. Exiting...", "");
            exit(EXIT_FAILURE);
        }
        print_status(id, "INFO", "Flow sucessfully processed. Exiting...", "");
    }

private:
    int
    start_extern() {
        std::string layer7protocol;
        find_and_return_parameter("layer7Protocol", layer7protocol);
        if (layer7protocol == "false") {
            print_status(id, "ERROR", "Could not find 'layer4Protocol' entry in parameter list", "");
            return -1;
        }
        if (layer7protocol == VOD) {
            if (setup_extern_vod() < 0) return -1;
        } else if (layer7protocol == MARKETPLACE || layer7protocol == STORAGE) {
            if (setup_extern_marketplace_storage() < 0) return -1;
        } else {
            print_status(id, "ERROR", "layer7Protocol Parameter is not supported", layer7protocol);
            return -1;
        }
        return 0;
    }

    /**
     * @author Philipp Spiegelt
     * Starts the requested attack type.
     *
     * @return Success value
     */
    int
    start_attack() {
        std::string attackType;
        find_and_return_parameter("attackType", attackType);
        if (attackType == "false") {
            print_status(id, "ERROR", "Could not find 'attackType' entry in parameter list", "");
            return -1;
        }
        if (attackType == SYNFLOOD) {
            if (setup_synflood() < 0) return -1;
        } else if (attackType == UDPFLOOD) {
            if (setup_udp_flood() < 0) return -1;
        } else if (attackType == SLOWLORIS) {
            if (setup_slowloris() < 0) return -1;
        } else if (attackType == SLOWPOST) {
            if (setup_slowpost() < 0) return -1;
        } else if (attackType == METASPLOIT) {
            if (setup_metasploit() < 0) return -1;
        } else if (attackType == PORTSCAN) {
            if (setup_portscan() < 0) return -1;
        } else {
            print_status(id, "ERROR", "attackType Parameter is not supported", attackType);
            return -1;
        }
    }


    int
    setup_extern_vod() {
        /* EXAMPLE
        cvlc -vvv --color http://192.168.88.8/BigBuckBunny_15s_onDemand_2014_05_09.mpd --sout '#duplicate{dst=display{novideo,noaudio}}'

        PARAMETERS THE USER MUST DEFINE
            server: consists of protocol, ip_dst, port_dst, manifest
            protocol: defines the video transmission protocol e.g. HTTP 1.1
            ip_dst: defines the server's ip address
            port_dst: defines the server's port address
            manifest: defines the video manifest
        */

        print_status(id, "INFO", "Layer 7 Protocol 'Video On Demand' detected", "");

        std::string server;
        if (setup_vod_server(server) < 0) return -1;
        VoD_External vod_object{id, server};
        if (vod_object.start_session() < 0) return -1;

        return 0;
    }

    int setup_metasploit() {
        print_status(id, "INFO", "attackType 'Metasploit' detected", "");

        unsigned int startDelaySec = 0;
        std::string logPath;
        unsigned int attempts = 1;
        std::string msfConnectionConfPath;
        std::string msfModuleConfPath;
        std::string pyMetasploitPath;

        if (setup_attack_metasploit(startDelaySec, logPath, attempts, msfConnectionConfPath, msfModuleConfPath,
                                    pyMetasploitPath) < 0)
            return -1;

        External_Metasploit metasploit_ob{id, pyMetasploitPath, startDelaySec, logPath, attempts, msfConnectionConfPath,
                                          msfModuleConfPath};
        if (metasploit_ob.start_session() < 0) return -1;

        return 0;
    }

    int setup_bruteforce_login() {
        print_status(id, "INFO", "attackType 'BruteForce Login' detected", "");

        std::string targetHost;
        unsigned int targetPort;
        std::string exploitName;
        std::string dictionaryPath;
        unsigned int startDelaySec = 0;
        unsigned int durationSec = 0;
        std::string logPath;

        if (setup_attack_general(startDelaySec, durationSec, logPath) < 0) return -1;
        if (setup_exploit_victim(targetHost, targetPort, exploitName) < 0) return -1;
        if (setup_dictionary(dictionaryPath) < 0) return -1;

        MSF_SSH_bruteforce bruteforce{id, startDelaySec, durationSec, targetHost, targetPort, exploitName,
                                      dictionaryPath};

        if (bruteforce.start_session() < 0) return -1;

        return 0;
    }

    int setup_exploit_victim(std::string &targetHost,
                             unsigned int &targetport,
                             std::string &exploitname) {
        std::string targetHost_unverified;
        std::string targetPort_unverified;
        std::string exploitName_unverified;

        find_and_return_parameter("host_dst", targetHost_unverified);
        find_and_return_parameter("port_dst", targetPort_unverified);
        find_and_return_parameter("exploit", exploitName_unverified);


        if (targetHost_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'targetHost' entry in parameter list", "");
            return -1;
        }
        if (targetPort_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'targetPort' entry in parameter list", "");
            return -1;
        }
        if (exploitName_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'exploitName' entry in parameter list", "");
            return -1;
        }

        targetHost = targetHost_unverified;
        targetport = static_cast<unsigned int>(std::stoi(targetPort_unverified));
        exploitname = exploitName_unverified;
        return 0;
    }

    int setup_dictionary(std::string &dictionaryPath) {
        std::string dicPath_unverified;
        find_and_return_parameter("userpassFile", dicPath_unverified);

        if (dicPath_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'userpassFile' entry in parameter list", "");
            return -1;
        }
        dictionaryPath = dicPath_unverified;
        return 0;
    }

    /**
     * @author: Philipp Spiegelt
     * @date: 04.01.19
     * Parameters:
     *      host_dst: target ip address.
     *      port: port to attack.
     *      interval: time between packets (in microseconds).
     *      host_src: which ip to spoof to (optional).
     */
    int setup_synflood() {

        print_status(id, "INFO", "attackType 'SYN Flooding' detected", "");

        std::string ip_dst;
        std::vector<std::string> ip_ssrc;
        unsigned int port;
        unsigned int interval = 0;
        std::string synfloodType = SYNFLOOD;
        unsigned int startDelaySec = 0;
        unsigned int durationSec = 0;
        std::string logPath;

        std::cout << "pre-setup attack general" << std::endl;
        if (setup_attack_general(startDelaySec, durationSec, logPath) < 0) return -1;

        std::cout << "pre-setup flooding victim" << std::endl;
        if (setup_flooding_victim(ip_dst, ip_ssrc, port, interval) < 0) return -1;

        std::cout << "pre-fork multiple" << std::endl;
        if (ip_ssrc.size() == 1) {
            std::cout << "starting single instance" << std::endl;
            SYN_Flooding_External sf_object{id, ip_dst, ip_ssrc[0], port, interval, startDelaySec, durationSec,
                                            logPath};
            if (sf_object.start_session() < 0) return -1;
            return 0;
        }
        std::cout << "starting multiple instances" << std::endl;
        L4_Distributed_Flooding df_object{id, ip_ssrc, synfloodType, ip_dst, port, interval, startDelaySec,
                                          durationSec, logPath};
        if (df_object.start_sessions() < 0) return -1;
        return 0;
    }

    /**
     * @author: Philipp Spiegelt
     * @date: 05.01.19
     * Parameters:
     *      host_dst: target ip address.
     *      port: port to attack.
     *      interval: time between packets (in microseconds).
     *      host_src: which ip to spoof to (optional).
     */
    int setup_udp_flood() {
        print_status(id, "INFO", "attackType 'UDP Flooding' detected", "");

        std::string ip_dst;
        std::vector<std::string> ip_ssrc;
        unsigned int port;
        unsigned int interval = 0;
        unsigned int startDelaySec = 0;
        unsigned int testDuration = 0;
        std::string logPath;

        if (setup_attack_general(startDelaySec, testDuration, logPath) < 0) return -1;
        if (setup_flooding_victim(ip_dst, ip_ssrc, port, interval) < 0) return -1;

        if (ip_ssrc.size() == 1) {
            UDP_Flooding_External udp_flood_object{id, ip_dst, ip_ssrc[0], port, interval, startDelaySec,
                                                   testDuration,
                                                   logPath};
            if (udp_flood_object.start_session() < 0) return -1;
            return 0;
        }
        L4_Distributed_Flooding df_object{id, ip_ssrc, "udpflood", ip_dst, port, interval, startDelaySec,
                                          testDuration,
                                          logPath};
        if (df_object.start_sessions() < 0) return -1;
        return 0;
    }

    /**
     * @author: Philipp Spiegelt
     * @date: 05.02.19
     * Parameters:
     *      url: URL of victim.
     *      num_connections: How many concurrent connections to use.
     *      delay: Interval between follow up data for Slow POST tests in seconds
     *      duration: Duration of the test in seconds.
     */
    int setup_slowpost() {
        print_status(id, "INFO", "attackType 'SlowPost' detected", "");

        std::string url;
        unsigned int numConnections;
        unsigned int dataDelay;
        unsigned int testDuration;
        unsigned int startDelaySec;
        bool generateCSV;
        std::string logPath;

        if (setup_attack_general(startDelaySec, testDuration, logPath) < 0) return -1;

        if (setup_slow_victim(url, numConnections, dataDelay, generateCSV) <
            0)
            return -1;

        SlowPost_External sl_object{id, url, numConnections, dataDelay, testDuration, startDelaySec, generateCSV,
                                    logPath};
        if (sl_object.start_session() < 0) return -1;

        return 0;
    }

    /**
     * @author: Philipp Spiegelt
     * @date: 04.02.19
     * Parameters:
     *      url: URL of victim.
     *      num_connections: How many concurrent connections to use.
     *      delay: Interval between follow up data for slowloris tests in seconds
     *      duration: Duration of the test in seconds.
     */
    int setup_slowloris() {
        print_status(id, "INFO", "attackType 'SlowLoris' detected", "");

        std::string url;
        unsigned int numConnections;
        unsigned int dataDelay;
        unsigned int testDuration;
        unsigned int startDelaySec = 0;
        bool generateCSV = true;
        std::string logPath;

        if (setup_attack_general(startDelaySec, testDuration, logPath) < 0) return -1;
        if (setup_slow_victim(url, numConnections, dataDelay, generateCSV) <
            0)
            return -1;
        SlowLoris_External sl_object{id, url, numConnections, dataDelay, testDuration, startDelaySec, generateCSV,
                                     logPath};
        if (sl_object.start_session() < 0) return -1;

        return 0;
    }

    int setup_attack_general(
            unsigned int &startDelaySec,
            unsigned int &duration,
            std::string &logPath
    ) {
        std::string startDelay_unverified;
        std::string logPath_unverified;
        unsigned int durationSec;

        find_and_return_parameter("startDelay", startDelay_unverified);
        durationSec = extract_nmbr_of_sth_with_default("duration", 0);
        find_and_return_parameter("logPath", logPath_unverified);

        if (startDelay_unverified != "false") {
            startDelaySec = extract_nmbr_of_sth("startDelay");
        }
        if (logPath_unverified == "false") {
            print_status(id, "INFO", "Could not find 'logPath' entry in parameter list, not creating logs", "");
            logPath_unverified = "";
        }

        duration = durationSec;
        logPath = logPath_unverified;

        return 0;
    }


    int setup_portscan() {
        print_status(id, "INFO", "attackType 'Portscan' detected", "");

        std::string ip_dst;
        std::string scanType;
        std::string logpath;
        std::string ports;
        unsigned int startDelaySec = 0;

        if (setup_portscan_options(ip_dst, scanType, logpath, ports, startDelaySec) < 0) return -1;

        Portscan_External portscan{id, ip_dst, scanType, logpath, ports, startDelaySec};
        if (portscan.start_session() < 0) return -1;
        return 0;

    }

    int setup_portscan_options(
            std::string &ip_dst,
            std::string &scanType,
            std::string &logpath,
            std::string &ports,
            unsigned int &startDelaySec) {

        std::string ip_dst_unverified;
        std::string scanType_unverified;
        std::string logpath_unverified;
        std::string ports_unverified;

        find_and_return_parameter("ip_dst", ip_dst_unverified);
        find_and_return_parameter("scan_type", scanType_unverified);
        find_and_return_parameter("log_path", logpath_unverified);
        find_and_return_parameter("ports", ports_unverified);
        startDelaySec = extract_nmbr_of_sth_with_default("startDelay", 0);

        if (ip_dst_unverified == "false" || scanType_unverified == "false" || ports == "false") {
            print_status(id, "ERROR", "One of the required fields is missing in the config!");
            return -1;
        }

        if (logpath_unverified == "false") {
            logpath_unverified = "";
        }

        ip_dst = ip_dst_unverified;
        scanType = scanType_unverified;
        logpath = logpath_unverified;
        ports = ports_unverified;
        return 0;
    }

    int
    setup_flooding_victim(std::string &targetAddress, std::vector<std::string> &sourceAddress,
                          unsigned int &targetPort,
                          unsigned int &interval) {

        std::string host_dst_unverified;
        std::string host_src_unverified;

        find_and_return_parameter("host_dst", host_dst_unverified);
        find_and_return_parameter("host_src", host_src_unverified);

        targetPort = extract_nmbr_of_sth("port_dst");
        interval = extract_nmbr_of_sth("interval");

        std::string f = "false";
        int error = 0;
        if (host_dst_unverified == f) {
            print_status(id, "ERROR", "Could not find 'ip_dst' entry in parameter list", "");
            error = 1;
        }
        if (host_src_unverified == f) {
            print_status(id, "INFO", "Could not find 'ip_src' entry in parameter list, using real IP", "");
            host_src_unverified = "";
        }

        if (error) return -1;

        targetAddress = host_dst_unverified;

        if (GPNTFUtil::ipRangeToVector(host_src_unverified, sourceAddress) < 0) return -1;

        return 0;
    }

    int setup_slow_victim(std::string &url,
                          unsigned int &numConnections,
                          unsigned int &delay,
                          bool &generateCSV) {
        std::string url_unverified;
        std::string genCSV_unverified;

        find_and_return_parameter("url", url_unverified);
        find_and_return_parameter("generate_csv", genCSV_unverified);

        if (url_unverified == "false") return -1;
        url = url_unverified;
        if (genCSV_unverified != "false") {
            generateCSV = extract_nmbr_of_sth("generate_csv") == 1;
        }

        numConnections = extract_nmbr_of_sth("num_connections");
        delay = extract_nmbr_of_sth("delay");

        return 0;
    }

    int setup_attack_metasploit(
            unsigned int &startDelaySec,
            std::string &logPath,
            unsigned int &attempts,
            std::string &msfConnectionConfPath,
            std::string &msfConfigPath,
            std::string &pyMetasploitPath
    ) {
        std::string logPath_unverified;
        std::string msfConnectionConfPath_unverified;
        std::string msfConfigPath_unverified;
        std::string pyMetasploitPath_unverified;

        startDelaySec = extract_nmbr_of_sth_with_default("startDelay", 0);
        attempts = extract_nmbr_of_sth_with_default("attempts", 1);

        find_and_return_parameter("logPath", logPath_unverified);
        if (logPath_unverified == "false") {
            print_status(id, "INFO", "Could not find 'logPath' entry in parameter list, not creating logs", "");
            logPath_unverified = "";
        }
        find_and_return_parameter("msf_connection", msfConnectionConfPath_unverified);
        if (msfConnectionConfPath_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'msf_connection' entry in parameter list!", "");
            return -1;
        }
        find_and_return_parameter("msf_module_conf", msfConfigPath_unverified);
        if (msfConfigPath_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'msf_module_conf' entry in parameter list!", "");
            return -1;
        }
        find_and_return_parameter("pymetasploit_dir", pyMetasploitPath_unverified);
        if (msfConfigPath_unverified == "false") {
            print_status(id, "ERROR", "Could not find 'pymetasploit_dir' entry in parameter list!", "");
            return -1;
        }
        logPath = logPath_unverified;
        msfConfigPath = msfConfigPath_unverified;
        msfConnectionConfPath = msfConnectionConfPath_unverified;
        pyMetasploitPath = pyMetasploitPath_unverified;
        return 0;
    }

    int
    setup_extern_marketplace_storage() {
        /* EXAMPLE
        iperf3 -c 192.168.88.8 -n 10M

        PARAMETERS THE USER MUST DEFINE:
            ip_dst: defines the target ip address,
            amount: defines the amount of data to send, see man iperf3 for format info;
        */

        print_status(id, "INFO", "Layer 7 Protocol 'Storage/Marketplace Upload' detected", "");

        std::string ip_dst;
        std::string amount;
        std::string flows;


        if (extern_marketplace_storage_collect_parameters(ip_dst, amount, flows) < 0) return -1;

        StorageMarketplace_External sm_object{id, ip_dst, amount, flows};
        if (sm_object.start_session() < 0) return -1;

        return 0;
    }

    int
    extern_marketplace_storage_collect_parameters(std::string &ip_dst, std::string &amount, std::string &flows) {
        find_and_return_parameter("ip_dst", ip_dst);
        if (ip_dst == "false") {
            print_status(id, "ERROR", "Could not fine 'ip_dst' entry in parameter list", "");
            return -1;
        }
        find_and_return_parameter("flows", flows);
        if (flows == "false") {
            print_status(id, "ERROR", "Could not fine 'flows' entry in parameter list", "");
            return -1;
        }

        find_and_return_parameter("amount", amount);
        if (amount == "false") {
            print_status(id, "ERROR", "Could not fine 'amount' entry in parameter list", "");
            return -1;
        }

        return 0;
    }

    int
    setup_extern_ftp() {
        std::string operation_mode;
        find_and_return_parameter("opMode", operation_mode);
        if (operation_mode == "false") {
            print_status(id, "ERROR", "Could not find 'opMode' entry in parameter list", "");
            return -1;
        }

        if (operation_mode == DOWNLOAD) {
            if (start_ftp_download() < 0) return -1;
            else return 0;
        } else if (operation_mode == UPLOAD) {
            if (start_ftp_upload() < 0) return -1;
            else return 0;
        } else {
            print_status(id, "ERROR", "Invalid entry for 'opMode'", operation_mode);
            return -1;
        }
    }

    int
    start_ftp_download() {
        /* EXAMPLE
        wget -mnH ftp://192.168.88.8/gpnft --ftp-user=ftpuser --ftp-password=erlkoenig
        */
        /* PARAMETERS THE USER MUST DEFINE:
            ip_dst, port_dst, file_path, user, passwd
        */
        print_status(id, "INFO", "Layer 7 Protocol 'FTP Download' detected", "");
        std::string server;
        if (setup_ftp_server(server) < 0) return -1;
        std::string user, passwd;
        if (setup_ftp_authentication(user, passwd) < 0) return -1;
        std::string path = "/usr/bin/wget";
        std::string file = "wget";
        std::string prmtrs = "-nH";
        std::string re = "-O-";

        unsigned int iterations = extract_nmbr_of_sth_with_default("iterations", ITERATIONS);

        int item = 1;
        for (unsigned int i = 0; i < iterations; ++i) {
            int wstatus;
            pid_t child = fork();

            if (child == -1) {
                print_status(id, "ERROR", "Forking failed: ", strerror(errno));
                return -1;
            }
            if (!child) {
                int dev_null = open("/dev/null", O_WRONLY);
                dup2(dev_null, 1);
                dup2(dev_null, 2);
                execl(path.c_str(), file.c_str(), prmtrs.c_str(), server.c_str(), re.c_str(), user.c_str(),
                      passwd.c_str(), NULL);
                return 0;
            } else {
                waitpid(child, &wstatus, 0);
            }
            std::cout << "ITEM FTP: " << item << std::endl;
            item++;
        }
        return 0;
    }

    int
    start_ftp_upload() {
        /* EXAMPLE
        wput ~/University/Master_Thesis/GPNTF/src/files/1080p.mpeg --basename=/home/bradatsch/University/Master_Thesis/GPNTF/src/files/
        ftp://ftpuser:erlkoenig@192.168.88.8:21
        */
        /* PARAMETERS THE USER MUST DEFINE:
            basename, file, user, passwd, ip_dst, port_dst
        */
        print_status(id, "INFO", "Layer 7 Protocol 'FTP Upload' detected", "");
        std::string path_to_exec = "/usr/bin/wput";
        std::string exec = "wput";

        std::string basename;
        find_and_return_parameter("basename", basename);
        if (basename == "false") return -1;

        std::string file_or_dir;
        find_and_return_parameter("file", file_or_dir);
        if (file_or_dir == "false") return -1;

        std::string upload = basename + "/" + file_or_dir;

        basename = "--basename=" + basename;

        std::string server = "ftp://";

        std::string user;
        find_and_return_parameter("user", user);
        if (user == "false") return -1;

        std::string passwd;
        find_and_return_parameter("passwd", passwd);
        if (passwd == "false") return -1;

        std::string ip_dst;
        find_and_return_parameter("ip_dst", ip_dst);
        if (ip_dst == "false") return -1;

        std::string port_dst;
        find_and_return_parameter("port_dst", port_dst);
        if (port_dst == "false") return -1;

        server += user + ":" + passwd + "@" + ip_dst + ":" + port_dst;

        int wstatus;
        pid_t child = fork();

        if (child == -1) {
            print_status(id, "ERROR", "Forking failed: ", strerror(errno));
            return -1;
        }
        if (!child) {
            int dev_null = open("/dev/null", O_WRONLY);
            dup2(dev_null, 1);
            dup2(dev_null, 2);
            execl(path_to_exec.c_str(), exec.c_str(), upload.c_str(), basename.c_str(), server.c_str(), NULL);
            return 0;
        } else {
            waitpid(child, &wstatus, 0);
            return 0;
        }
    }

    int
    setup_vod_server(std::string &server) {
        std::string protocol;
        find_and_return_parameter("protocol", protocol);
        std::string ip_dst;
        find_and_return_parameter("ip_dst", ip_dst);
        std::string port_dst;
        find_and_return_parameter("port_dst", port_dst);
        std::string manifest;
        find_and_return_parameter("manifest", manifest);

        std::string f = "false";
        int error = 0;
        if (protocol == f) {
            print_status(id, "ERROR", "Could not find 'protocol' entry in parameter list", "");
            error = 1;
        }
        if (ip_dst == f) {
            print_status(id, "ERROR", "Could not find 'ip_dst' entry in parameter list", "");
            error = 1;
        }
        if (port_dst == f) {
            print_status(id, "ERROR", "Could not find 'port_dst' entry in parameter list", "");
            error = 1;
        }
        if (manifest == f) {
            print_status(id, "ERROR", "Could not find 'manifest' entry in parameter list", "");
            error = 1;
        }

        if (error) return -1;

        server = protocol + "://" + ip_dst + ":" + port_dst + "/" + manifest;

        return 0;
    }

    int
    setup_ftp_server(std::string &server) {
        std::string protocol = "ftp";
        std::string ip_dst;
        find_and_return_parameter("ip_dst", ip_dst);
        std::string port_dst;
        find_and_return_parameter("port_dst", port_dst);
        std::string file_path;
        find_and_return_parameter("file_path", file_path);

        std::string f = "false";
        int error = 0;
        if (file_path == f) {
            print_status(id, "ERROR", "Could not find 'file_path' entry in parameter list", "");
            error = 1;
        }
        if (ip_dst == f) {
            print_status(id, "ERROR", "Could not find 'ip_dst' entry in parameter list", "");
            error = 1;
        }
        if (port_dst == f) {
            print_status(id, "ERROR", "Could not find 'port_dst' entry in parameter list", "");
            error = 1;
        }

        if (error) return -1;

        server = protocol + "://" + ip_dst + ":" + port_dst + "/" + file_path;

        return 0;
    }


    int
    setup_ftp_authentication(std::string &user, std::string &passwd) {
        std::string username;
        find_and_return_parameter("user", username);
        std::string password;
        find_and_return_parameter("passwd", password);

        std::string f = "false";
        int error = 0;
        if (username == f) {
            print_status(id, "ERROR", "Could not find 'username' entry in parameter list", "");
            error = 1;
        }
        if (password == f) {
            print_status(id, "ERROR", "Could not find 'passwd' entry in parameter list", "");
            error = 1;
        }

        if (error) return -1;

        user = "--ftp-user=" + username;
        passwd = "--ftp-password=" + password;

        return 0;
    }

    int
    start_regular() {
        std::vector<std::shared_ptr<L4>> sockets;
        if (setup_regular_layer4(sockets) < 0) return -1;
        if (setup_regular_layer7(sockets) < 0) return -1;
        return 0;
    }

    int
    setup_regular_layer4(std::vector<std::shared_ptr<L4>> &sockets) {
        unsigned int nof_connections = extract_nmbr_of_sth_with_default(NOF_CONNECTIONS, DEFAULT_NOF_CONNECTIONS);
        if (!nof_connections) return -1;

        std::string layer4protocol;
        find_and_return_parameter("layer4Protocol", layer4protocol);
        if (layer4protocol != "false") {
            /* --- TCP --- */
            if (layer4protocol == LAYER4_TCP) {
                for (unsigned int i = 0; i < nof_connections; ++i) {
                    if (setup_regular_tcp(sockets) < 0) return -1;
                }
            }
                /* --- UDP --- */
            else if (layer4protocol == LAYER4_UDP) {
                for (unsigned int i = 0; i < nof_connections; ++i) {
                    if (setup_regular_udp(sockets) < 0) return -1;
                }
            }
                /* --- DEFAULT --- */
            else {
                std::cout << "> [" << id << "] WARNING: Layer 4 protocol " << layer4protocol << ""
                                                                                                " not yet supported."
                          << std::endl;
                return -1;
            }
        } else {

            std::cout << "> [" << id << "] ERROR: Could not find 'layer4Protocol' entry in parameter list"
                      << std::endl;
            return -1;
        }
        return 0;
    }

    int
    setup_regular_tcp(std::vector<std::shared_ptr<L4>> &sockets) {
        std::cout << "> [" << id << "] INFO: Layer 4 protocol 'TCP' detected." << std::endl;
        std::cout << "> [" << id << "] INFO: Trying to set up regular TCP socket..." << std::endl;

        std::string ip_dst;
        find_and_return_parameter("ip_dst", ip_dst);
        if (ip_dst == "false") {
            std::cout << "> [" << id << "] ERROR: Could not find 'ip_dst' entry in parameter list." << std::endl;
            return -1;
        }

        std::string port_dst;
        find_and_return_parameter("port_dst", port_dst);
        if (port_dst == "false") {
            std::cout << "> [" << id << "] ERROR: Could not find 'port_dst' entry in parameter list." << std::endl;
            return -1;
        }

        sockets.push_back(std::make_shared<TCP>(id, ip_dst, port_dst));
        /*
        if(sockets.back()->setup_socket(ip_dst_it->second, tcp_dst_it->second) < 0) {
            std::cout << "> [" << id << "] ERROR: Could not set up regular TCP socket." << std::endl;
            sockets.pop_back();
            return -1;
        }
        */
        return 0;
    }

    int
    setup_regular_udp(std::vector<std::shared_ptr<L4>> &sockets) {
        print_status(id, "INFO", "Layer 4 protocol 'UDP' detected.");
        print_status(id, "INFO", "Trying to set up regular UDP socket...");

        std::string ip_dst;
        find_and_return_parameter("ip_dst", ip_dst);
        if (ip_dst == "false") {
            print_status(id, "ERROR", "Could not find 'ip_dst' entry in parameter list.");
            return -1;
        }

        std::string port_dst;
        find_and_return_parameter("port_dst", port_dst);
        if (port_dst == "false") {
            print_status(id, "ERROR", "Could not find 'port_dst' entry in parameter list.");
            return -1;
        }

        sockets.push_back(std::make_shared<UDP>(id, ip_dst, port_dst));
        /*
        if(sockets.back()->setup_socket() < 0) {
            std::cout << "> [" << id << "] ERROR: Could not set up regular UDP socket." << std::endl;
            sockets.pop_back();
            return -1;
        }
        */
        return 0;
    }

    int
    setup_regular_layer7(std::vector<std::shared_ptr<L4>> &sockets) {
        typename std::map<Key, Value>::const_iterator layer7protocol_it = parameters.find("layer7Protocol");
        if (layer7protocol_it != parameters.end()) {
            /* --- F1460B ---*/
            if (layer7protocol_it->second == LAYER7_1460B) {
                return setup_regular_f1460b(sockets);
            }
                /* --- Web Browsing ---*/
            else if (layer7protocol_it->second == LAYER7_WEBBROWSING) {
                return setup_regular_webbrowsing(sockets);
            }
                /* --- File Sharing ---*/
            else if (layer7protocol_it->second == LAYER7_FILESHARING) {
                return setup_regular_filesharing(sockets);
            }
                /* --- DEFAULT --- */
            else {
                std::cout << "> [" << id << "] WARNING: Layer 7 protocol " << layer7protocol_it->second << ""
                                                                                                           " not yet supported."
                          << std::endl;
                return -1;
            }
        } else {
            std::cout << "> [" << id << "] ERROR: Could not find 'layer7Protocol' entry in parameter list"
                      << std::endl;
            return -1;
        }
        return 0;
    }

    int
    setup_regular_filesharing(std::vector<std::shared_ptr<L4>> &sockets) {
        std::cout << "> [" << id << "] INFO: Layer 7 protocol 'File Sharing' detected." << std::endl;

        std::string ip_dst, port_dst;
        find_and_return_parameter("ip_dst", ip_dst);
        find_and_return_parameter("tcp_dst", port_dst);

        std::vector<std::string> ips, ports;
        ips.push_back(ip_dst);
        ports.push_back(port_dst);

        bool logging = true;
        std::string path = "./";
        unsigned int session_length = extract_nmbr_of_sth_with_default("sessionLength", DEFAULT_SESSION_LENGTH);
        unsigned int idle_time_ms = extract_nmbr_of_sth_with_default("idleTime", DEFAULT_IDLE_TIME);
        if (!session_length) return -1;

        File_Sharing<L4> test{sockets, logging, path, id, session_length, idle_time_ms, ips, ports};
        test.start_session();
        return 0;
    }

    int
    setup_regular_webbrowsing(std::vector<std::shared_ptr<L4>> &sockets) {
        std::cout << "> [" << id << "] INFO: Layer 7 protocol 'Web Browsing' detected." << std::endl;

        bool logging = true;
        std::string path = "./";
        std::shared_ptr<Distribution_Function> view_time_dist{new Lognormal_Distribution{-0.495204, 2.7731}};
        std::shared_ptr<Distribution_Function> nof_inline_objects_dist{new Exponential_Distribution{1 / 31.9291}};
        unsigned int request_size = WEB_BROWSING_DEFAULT_REQUEST_SIZE;
        unsigned int session_length = extract_nmbr_of_sth_with_default("sessionLength",
                                                                       WEB_BROWSING_DEFAULT_SESSION_LENGTH);

        Web_Browsing<L4> test{sockets, logging, path, id, request_size, session_length, view_time_dist,
                              nof_inline_objects_dist};
        test.start_session();
        return 0;
    }

    int
    setup_regular_f1460b(std::vector<std::shared_ptr<L4>> &sockets) {
        std::cout << "> [" << id << "] INFO: Layer 7 protocol 'F1460B' detected." << std::endl;

        typename std::map<Key, Value>::const_iterator layer7mode_it = parameters.find("layer7Mode");
        if (layer7mode_it != parameters.end()) {
            /* --- F1460B CONSTANT MODE --- */
            if (layer7mode_it->second == LAYER7_1460B_CONST) {
                return setup_regular_f1460b_const(sockets);
            }
                /* --- DEFAULT --- */
            else {
                std::cout << "> [" << id << "] WARNING: Layer 7 mode " << layer7mode_it->second << ""
                                                                                                   " not yet supported."
                          << std::endl;
                return -1;
            }
        } else {
            std::cout << "> [" << id << "] ERROR: Could not find 'layer7Mode' entry in parameter list" << std::endl;
            return -1;
        }
    }

    int
    setup_regular_f1460b_const(std::vector<std::shared_ptr<L4>> sockets) {
        std::cout << "> [" << id << "] INFO: Layer 7 mode 'F1460B_CONST' detected." << std::endl;

        std::string path = "./";
        unsigned int nmbr_of_packets = extract_nmbr_of_sth("packetsToSend");
        if (!nmbr_of_packets) return -1;

        F1460B_const<L4> test{sockets, true, path, nmbr_of_packets};
        test.start();
        return 0;
    }

    unsigned int
    extract_nmbr_of_sth(std::string keyword) {
        typename std::map<Key, Value>::const_iterator nmbrOfSth_it = parameters.find(keyword);
        if (nmbrOfSth_it != parameters.end()) {
            if (strtod(nmbrOfSth_it->second.c_str(), NULL) <= 0) {
                std::cerr << "> [" << id << "] ERROR: Value of " << keyword << " is zero or negative" << std::endl;
            }
            try {
                unsigned int nmbr_of_sth = std::stoul(nmbrOfSth_it->second, nullptr, 0);
                return nmbr_of_sth;
            }
            catch (const std::invalid_argument &ia) {
                std::cerr << "> [" << id << "] ERROR: Value of " << keyword << " is not an Unsigned Integer"
                          << std::endl;
                return 0;
            }
            catch (const std::out_of_range &oor) {
                std::cerr << "> [" << id << "] ERROR: Value of " << keyword << " is out of range" << std::endl;
                return 0;
            }
        } else {
            std::cout << "> [" << id << "] ERROR: Could not find " << keyword << " entry in parameter list"
                      << std::endl;
            return 0;
        }
    }

/* ---  Returns 0 On Error; Else defaultValue Or The Actual Value:
        TODO: RV -1 maybe better? --- */
    unsigned int
    extract_nmbr_of_sth_with_default(std::string keyword, unsigned int defaultValue) {
        typename std::map<Key, Value>::const_iterator nmbrOfSth_it = parameters.find(keyword);
        if (nmbrOfSth_it != parameters.end()) {
            if (strtod(nmbrOfSth_it->second.c_str(), NULL) < 0) {
                std::cerr << "> [" << id << "] ERROR: Value of " << keyword << " is zero or negative"
                          << std::endl;
                return 0;
            }
            try {
                unsigned int nmbr_of_sth = std::stoul(nmbrOfSth_it->second, nullptr, 0);
                return nmbr_of_sth;
            }
            catch (const std::invalid_argument &ia) {
                std::cerr << "> [" << id << "] ERROR: Value of " << keyword << " is not an Unsigned Integer"
                          << std::endl;
                return 0;
            }
            catch (const std::out_of_range &oor) {
                std::cerr << "> [" << id << "] ERROR: Value of " << keyword << " is out of range" << std::endl;
                return 0;
            }
        } else {
            std::cout << "> [" << id << "] INFO: Could not find " << keyword << " entry in parameter list."
                      << " Continuing with default value..." << defaultValue << std::endl;
            return defaultValue;

        }
    }

    void
    find_and_return_parameter(std::string keyword, std::string &value) {
        typename std::map<Key, Value>::const_iterator it = parameters.find(keyword);

        if (it == parameters.end()) {
            value = "false";
        } else {
            value = it->second;
        }
    }

/* --- EXPERIMENTAL --- */
    template<typename T>
    void synced_print(T t) const {
        write(1, t.c_str(), t.length());
    }

    template<typename T, typename... Args>
    void synced_print(T t, Args... args) const {
        write(1, t.c_str(), t.length());
        synced_print(args...);
    }

    unsigned int id;
    std::map<Key, Value> parameters;
};

#endif
